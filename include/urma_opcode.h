/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.
 * Description: URMA opcode header file
 * Author: Ouyang Changchun, Yan Fangfang, Qian Guoxin
 * Create: 2021-09-26
 * Note:
 * History: 2021-09-26   Create File
 */

#ifndef URMA_OPCODE_H
#define URMA_OPCODE_H

/* urma bit field value */
#define URMA_KEY_NONE             0              /* Indicates the verification policy of the key. */
#define URMA_KEY_PLAIN_TEXT       1
#define URMA_KEY_SIGNED           2
#define URMA_KEY_ALL_ENCRYPTED    3
#define URMA_KEY_RESERVED         4

#define URMA_DSVA_DISABLE         0              /* Indicates whether it is a segment of dsva. */
#define URMA_DSVA_ENABLE          1

#define URMA_NON_CACHEABLE        0              /* Indicates whether the segment can be cached by multiple hosts. */
#define URMA_CACHEABLE            1

#define URMA_ACCESS_LOCAL_WRITE   (0x1 << 0)
#define URMA_ACCESS_REMOTE_READ   (0x1 << 1)
#define URMA_ACCESS_REMOTE_WRITE  (0x1 << 2)
#define URMA_ACCESS_REMOTE_ATOMIC (0x1 << 3)
#define URMA_ACCESS_REMOTE_INVALIDATE (0x1 << 4)

#define URMA_LOCAL_MEMORY         0              /* Indicates that the physical memory is remote. */
#define URMA_REMOTE_MEMORY        1

#define URMA_SEG_NOMAP            0              /* Indicates that the current process has mapped this segment */
#define URMA_SEG_MAPPED           1

#define URMA_ADDR_TYPE_MVA        0
#define URMA_ADDR_TYPE_UBVA       1

#define URMA_COMPLETE_ENABLE      1              /* Notify the source after the task is completed. */
#define URMA_COMPLETE_DISABLE     0              /* Do not notify the source after the task is complete. */

#define URMA_COMPLETE_TYPE_JFC    0              /* Complete notification via JFC. */
#define URMA_COMPLETE_TYPE_CF     1              /* Complete notification via DDR address */

#define URMA_DEPENDENCY_NONE      0              /* There is no dependency between commands. */
#define URMA_DEPENDENCY_FIRST     1              /* Subsequent commands depend on the execution result \
                                                     of the current command. */
#define URMA_DEPENDENCY_DELAY     2              /* The current command is executed only when the command \
                                                     that the preamble depends on is executed successfully. */

#define URMA_NOTIFY_DISABLE       0              /* The destination is not notified when the task is completed. */
#define URMA_NOTIFY_ENABLE        1              /* Notify the destination when the task is completed. */

#define URMA_NOTIFY_TYPE_JFC      0              /* Complete notification via JFC. */
#define URMA_NOTIFY_TYPE_RVA      1              /* Complete notification via DDR address. */

#define URMA_INLINE_DISABLE       0              /* The data is generated by source_address assignment. */
#define URMA_INLINE_ENABLE        1              /* The data is carried in the command. */

#define URMA_SOLICITED_DISABLE    0              /* There is no interruption when notifying through JFC. */
#define URMA_SOLICITED_ENABLE     1              /* Interrupt occurred while notifying via JFC. */

#define URMA_FENCE_DISABLE        0              /* There is no fence. */
#define URMA_FENCE_ENABLE         1              /* Fence with previous WRs. */

#define URMA_REGULAR              1              /* regular, specifies stride format. */
#define URMA_IRREGULAR            0              /* irregular, specifies S/G format. */

#define URMA_NO_TAG_MATCHING      0
#define URMA_WITH_TAG_MATCHING    1

#define URMA_IDC_MODE             0
#define URMA_DC_MODE              1
#define URMA_LS_MODE              2

#define URMA_NONPOST_LS           0
#define URMA_POST_LS              1

#define URMA_NO_SHARE_JFR         0
#define URMA_SHARE_JFR            1

#define URMA_TYPICAL_RETRY_CNT    7             /* typical value of retry cnt for jfs cfg */
#define URMA_TYPICAL_RNR_RETRY    7             /* typical value of rnr retry for jfs cfg */
#define URMA_TYPICAL_ERR_TIMEOUT   17           /* typical value of err_timeout for jfs cfg */
#define URMA_TYPICAL_MIN_RNR_TIMER 12           /* typical value of min_rnr_timer for jfr cfg */
#define URMA_MAX_PRIORITY 15

/* operation infomation */
typedef enum urma_order_type {
    URMA_NO_ORDER = 0,     // No order
    URMA_RELAX_ORDER,      // Relax order
    URMA_STRONG_ORDER      // Strong order
} urma_order_type_t;

/* opcode definition */
typedef enum urma_opcode {
    URMA_OPC_WRITE              = 0x00,
    URMA_OPC_WRITE_IMM          = 0x01,
    URMA_OPC_WRITE_NOTIFY       = 0x02, // not support result will return for URMA_OPC_WRITE_NOTIFY
    URMA_OPC_READ               = 0x10,
    URMA_OPC_CAS                = 0x20,
    URMA_OPC_FAA                = 0x21,
    URMA_OPC_CAS_WITH_MASK      = 0x24,
    URMA_OPC_FAA_WITH_MASK      = 0x25,
    URMA_OPC_SEND               = 0x40, // remote JFR/jetty ID
    URMA_OPC_SEND_IMM           = 0x41, // remote JFR/jetty ID
    URMA_OPC_SEND_INVALIDATE    = 0x42, // remote JFR/jetty ID and seg token id
    URMA_OPC_NOP                = 0x51,
    URMA_OPC_LAST
} urma_opcode_t;

typedef enum urma_status {
    URMA_SUCCESS = 0,
    URMA_EAGAIN = 0x1000,   // Resource temporarily unavailable
    URMA_ENOMEM,            // Failed to allocate memory
    URMA_ENOPERM,           // Operation not permitted
    URMA_ETIMEOUT,          // Operation time out
    URMA_EINVAL,            // Invalid argument
    URMA_EEXIST,            // Exist
    URMA_FAIL,
} urma_status_t;

/* completion infomation */
typedef enum urma_cr_status { // completion record status
    URMA_CR_SUCCESS = 0,
    URMA_CR_LOC_LEN_ERR,           // Local data too long error
    URMA_CR_LOC_OPERATION_ERR,     // Local operation err
    URMA_CR_LOC_PROTECTION_ERR,    // Local memory protection error
    URMA_CR_LOC_ACCESS_ERR,        // Access to local memory error when WRITE_WITH_IMM
    URMA_CR_REM_INVALID_REQ_ERR,   // The work request is detected as invalid by the remote side
    URMA_CR_REM_ACCESS_ERR,        // Memory access protection error occurred in the remote node
    URMA_CR_REM_OPERATION_ERR,     // Error when target jetty can not complete the operation
    URMA_CR_REM_ABORT_ERR,         // Error when target jetty abort the operation
    URMA_CR_RETRY_CNT_EXC_ERR,     // Retransmission exceeds the maximum number of times
    URMA_CR_RNR_RETRY_CNT_EXC_ERR, // RNR retries exceeded the maximum number: remote jfr has no buffer
    URMA_CR_FATAL_ERR,
    URMA_CR_WR_FLUSH_ERR,
    URMA_CR_RESP_TIMEOUT_ERR,
    URMA_CR_MORE_TO_POLL_ERR,
    URMA_CR_GENERAL_ERR
} urma_cr_status_t;

typedef enum urma_cr_opcode {
    URMA_CR_OPC_SEND = 0x00,
    URMA_CR_OPC_SEND_WITH_IMM,
    URMA_CR_OPC_SEND_WITH_INV,
    URMA_CR_OPC_WRITE_WITH_IMM,
} urma_cr_opcode_t;

/* event infomation */
typedef enum urma_async_event_type {
    URMA_EVENT_JFC_ERR,
    URMA_EVENT_JFS_FATAL,
    URMA_EVENT_JFS_ACCESS_ERR,
    URMA_EVENT_JFR_FATAL,
    URMA_EVENT_JFR_ACCESS_ERR,
    URMA_EVENT_JETTY_FATAL,
    URMA_EVENT_JETTY_ACCESS_ERR,
    URMA_EVENT_PORT_ACTIVE,
    URMA_EVENT_PORT_ERR,
    URMA_EVENT_DEV_FATAL,
    URMA_EVENT_ID_CHANGE     // eid | cid change, HNM and other management roles will be modified.
} urma_async_event_type_t;

typedef enum urma_jfc_state {
    URMA_JFC_STATE_INVALID = 0,
    URMA_JFC_STATE_VALID,
    URMA_JFC_STATE_ERROR
} urma_jfc_state_t;

typedef enum urma_jetty_state {
    URMA_JETTY_STATE_RESET = 0,
    URMA_JETTY_STATE_READY,
    URMA_JETTY_STATE_SUSPENDED,
    URMA_JETTY_STATE_ERROR
} urma_jetty_state_t;

typedef enum urma_jfr_state {
    URMA_JFR_STATE_RESET = 0,
    URMA_JFR_STATE_READY,
    URMA_JFR_STATE_ERROR
} urma_jfr_state_t;
#endif // URMA_OPCODE_H
